FREERTOS:
By default, esp32 uses FreeRTOS to manage dual-core and other peripherals
Main task runs app_main() at which point if reaching superloop processing point
would include a vTaskDelay(1000 / portTICK_RATE_MS) 

naming prefix letter is return type?
lower case word prefix is constant?
xQueueCreate() --> xQueueSendFromISR() --> xQueueRecieve() in task to periodically dequeue
(FreeRTOS Queue makes copy of data. Seems only use this for ease-of-use?)

error handling: if (unlikely(res) != OK) ...

Peripheral Workflow:
Interrupt populate FIFO queue
Task check queue and perform particular operation

IMPORTANT: as esp32 comes with default bootloader, it may use peripherals already, e.g. bootloader uses UART0


The keyword `volatile` is used when code other than what is generated by the compiler could modify the value.

SYNCHRONISATION:
Atomic means no other thread will see the operation in a partially completed state
A lock free program can never be stalled and will have predictable latency
Whilst it has the potential to be faster than using locks as all threads can run for their full quanta,
they can be slower as you have to write more code to work around the basic CAS (Compare And Swap)

Locks implemented using atomics
Designed for coordinated access to data shared across threads 
A lock is a mechanism that controls execution flow. 
It can be acquired or released.
Various implementations of locks:
* Semaphore
  Each acquisition decrements counter.
  Counting semaphore has variable counter value.
  Binary semaphore has counter value as 1
  If cannot acquire, will be put to sleep 
* Mutex 
  Introduces ownership to a binary semaphore. 
  This solves possible issues with semaphores, e.g. accidental unlock as only owning thread can release
  If cannot acquire, will be put to sleep 
* Spinlock
  A mutex that instead of sleeping, will be put in a busy loop if cannot acquire. 
  If locked only for a small amount of time, the act of performing context switching by the scheduler will be slower than looping over and checking again
* Hybrid Mutex/Spinlock
  Most OSs implement them for efficiency.
  They will first behave as a standard mutex/spinlock that will revert to the other after some predefined condition


Chips found on board are USB-UART chip and low dropout voltage regulator (meaning can work even if supply and load voltages are very close)

ESP32 more so Harvard, as actually has IRAM (e.g. to hold ISRs? just to ensure faster access than from Flash?) and DRAM?

xtensa has unpublished ISA (however some esp32 moving to RISC-V), 
closed source for wifi/bluetooth drivers (meaning proprietary binary blobs filling unknown slots in RAM
however, common for WiFi drivers due to precertification, i.e. don't allow users to output RF in unlicensed bands), 
less IO ports, bad ADC, higher power draw, tied to SDK for usage
so not an option for control or most industrial applications


UWD (ultra-wideband) is short range RF used to detect people and devices
ESP32 has an MMU, unlike Cortex-M
Xtensa ISA -> Tensilica cpu -> EspressIf ESP32 mcu
Good as cheap for sufficiently high speed baseband (one channel) WiFi and Bluetooth
Useful for video and audio streaming (comes with compression audio codecs to transmit via bluetooth)
Can be used as an OTT (over-the-top) device, i.e. connect something to the Internet

Small amount of RAM < 1MB, e.g. wanting to do some real-time processing on chip can use QSPI to use more flash and ram
(So, most MCU with small number of memory, more can be added)

PCM (pulse code modulation) requires changing values to generate noise
I2S for reading microphone? So I2S PCM interface for audio?

5MHz I2C is considered fast?

SDIO is high-speed SD card protocol, (sd 3.0?)
NO, SDIO IS FAST SPI?

is 12-bit SAR (successive approximation) ADC with 18 channels good?

Seems that RTC is intertwined with low-power functioning, i.e. when main cpu in deep sleep

TODO: AES, RSA, SHA, RNG

TODO: package information QFN 5*5, i.e. 5mmx5mm (QFN is fab process? this is small size so good for portable projects)

Schematic has power supply, crystal (ppm parts per million is how much crystal will deviate), flash and RF antenna 
Does the minimum system schematic mean the essential components that have to be connected to the MCU for it to work? 
So the simple minimum system here makes PCB design simpler
However, are all schematics shown indicative of this 'minimum system'?

ESP-IDF (EspressIf IoT Development Framework) which is primarily a python virtual environment with lots of packages
to faciliate configuration, library retrieval, building, flashing, etc.

$(get_idf) sets up path
$(idf.py set-target esp32) will do a cmake --configure
$(idf.py menuconfig) is like linux kernel kconfig and will generate a sdkconfig
$(idf.py build) generate large number of drivers, as well as a bootloader, partition table and application binary 
$(idf.py -p /dev/ttyUSB0 flash monitor) (add user to dialout group)
IMPORTANT: Issue on Ubuntu serial flashing driver whereby the particular RS232 signals aren't being sent properly to
put the chip into programming mode, so have to hold down Boot button until flashing percentage and then release

infrared is heat. LED can give of narrow band of infrared.
Therefore, can be used as an IR remote control that requires line of sight.
Hence RMT (remote control reciever) refers to infrared

TODO: What are ESP-IDF Components and how to integrate them with Component Manager

IMPORTANT: Inspecting gpio voltage level on oscilloscope shows ringing, i.e. signal plateuing (so, always present?)

